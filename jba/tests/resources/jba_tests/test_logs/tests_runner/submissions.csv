task_name,lesson_name,section_name,submission_datetime,status,user_id,code_snippets,id
FinishTheApp,LastPush,Introduction,2023-06-27 17:32:31.123456,wrong,1,"[{""name"":""src/main/kotlin/Main.kt"",""text"":""fun fillPatternRow(patternRow: String, patternWidth: Int) = if (patternRow.length <= patternWidth) {\n    val filledSpace = \""$separator\"".repeat(patternWidth - patternRow.length)\n    \""$patternRow$filledSpace\""\n} else {\n    error(\""patternRow length > patternWidth, please check the input!\"")\n}\n\nfun getPatternHeight(pattern: String) = pattern.lines().size\n\nfun repeatHorizontally(pattern: String, n: Int, patternWidth: Int): String {\n    val pictureRows = pattern.lines()\n    val sb = StringBuilder()\n    for (row in pictureRows) {\n        val currentRow = fillPatternRow(row, patternWidth)\n        sb.append(currentRow.repeat(n))\n        sb.append(newLineSymbol)\n    }\n    return sb.toString()\n}\n\nfun dropTopFromLine(line: String, width: Int, patternHeight: Int, patternWidth: Int): String {\n    val nToDrop = if (patternHeight > 1) {\n        patternWidth * width + newLineSymbol.length\n    } else {\n        0\n    }\n    val newPattern = line.removeSuffix(newLineSymbol).drop(nToDrop)\n    return \""$newPattern$newLineSymbol\""\n}\n\nfun baseGenerator(firstLine: String, secondLine: String, height: Int): String {\n    val sb = StringBuilder()\n    sb.append(firstLine)\n    return when {\n        height < 1 -> \""\""\n        height == 1 -> sb.toString()\n        else -> {\n            sb.append(secondLine)\n            sb.append(repeatVertically(firstLine, secondLine, height))\n            sb.toString()\n        }\n    }\n}\n\nfun repeatVertically(firstLine: String, secondLine: String, height: Int): String {\n    val currentHeight = makeEvenNumber(height) / 2 - 1\n    val pattern = \""$firstLine$secondLine\"".repeat(currentHeight)\n    return if (height % 2 == 0) {\n        pattern\n    } else {\n        \""$pattern$firstLine\""\n    }\n}\n\nfun makeEvenNumber(number: Int) = if (number % 2 == 0) {\n    number\n} else {\n    number - 1\n}\n\nfun canvasGenerator(pattern: String, width: Int, height: Int): String {\n    val patternWidth = getPatternWidth(pattern)\n    val patternHeight = getPatternHeight(pattern)\n    val repeatedPattern = repeatHorizontally(pattern, width, patternWidth)\n    val dropped = dropTopFromLine(repeatedPattern, width, patternHeight, patternWidth)\n    return \""$repeatedPattern${baseGenerator(dropped, dropped, height - 1)}\""\n}\n\nfun addEmptyWindow(patternRow: String, patternWidth: Int, toAddAfter: Boolean = false): String {\n    val separator = \""$separator\"".repeat(patternWidth)\n    return if (toAddAfter) {\n        \""$patternRow$separator\""\n    } else {\n        \""$separator$patternRow\""\n    }\n}\n\nfun isEmpty(pattern: String) = pattern == \""\""\n\nfun repeatHorizontallyWithGaps(pattern: String, n: Int, toAddSeparatorAfter: Boolean): String {\n    val pictureRows = pattern.lines()\n    val patternWidth = getPatternWidth(pattern)\n    val sb = StringBuilder()\n    for (row in pictureRows) {\n        val currentRow = fillPatternRow(row, patternWidth)\n\n        val currentRwSb = StringBuilder()\n        val currentWidth = makeEvenNumber(n) / 2\n        val patternToRepeat = addEmptyWindow(currentRow, patternWidth, toAddSeparatorAfter).repeat(currentWidth)\n        if (isEmpty(patternToRepeat)) {\n            currentRwSb.append(currentRow)\n        } else {\n            currentRwSb.append(patternToRepeat)\n        }\n        if (n % 2 != 0 && !isEmpty(patternToRepeat)) {\n            currentRwSb.append(patternToRepeat.dropLast(patternToRepeat.length - currentRow.length))\n\n        sb.append(currentRwSb.toString())\n        sb.append(newLineSymbol)\n    }\n    return sb.toString()\n}\n\nfun canvasWithGapsGenerator(pattern: String, width: Int, height: Int): String {\n    val firstLine = repeatHorizontallyWithGaps(pattern, width, true)\n    val secondLine = repeatHorizontallyWithGaps(pattern, width, false)\n    return baseGenerator(firstLine, secondLine, height)\n}\n\nfun applyGenerator(pattern: String, generatorName: String, width: Int, height: Int) = when (generatorName) {\n    \""canvas\"" -> canvasGenerator(pattern.trimIndent(), width, height)\n    \""canvasGaps\"" -> canvasWithGapsGenerator(pattern.trimIndent(), width, height)\n    else -> error(\""Unsupported generator: $generatorName\"")\n}\n\nfun getPattern(): String {\n    println(\n        \""Do you want to use a pre-defined pattern or a custom one? \"" +\n                \""Please input 'yes' for a pre-defined pattern or 'no' for a custom one\""\n    )\n    do {\n        when (safeReadLine()) {\n            \""yes\"" -> {\n                return choosePattern()\n            }\n            \""no\"" -> {\n                println(\""Please, input a custom picture\"")\n                return safeReadLine()\n            }\n            else -> println(\""Please input 'yes' or 'no'\"")\n        }\n    } while (true)\n}\n\nfun choosePattern(): String {\n    do {\n        println(\""Please choose a pattern. The possible options: ${allPatterns().joinToString(\"", \"")}\"")\n        val name = safeReadLine()\n        val pattern = getPatternByName(name)\n        pattern?.let {\n            return pattern\n        }\n    } while (true)\n}\n\nfun chooseGenerator() {\n    var toContinue = true\n    var generator = \""\""\n    println(\""Please choose the generator: 'canvas' or 'canvasGaps'.\"")\n    do {\n        when (val input = safeReadLine()) {\n            \""canvas\"", \""canvasGaps\"" -> {\n                toContinue = false\n                generator = input\n            }\n            else -> println(\""Please, input 'canvas' or 'canvasGaps'\"")\n        }\n    } while (toContinue)\n    return generator\n}\n\nfun safeReadLine(): String = readlnOrNull() ?: error(\""Your input is incorrect, sorry\"")\n\nfun main() {\n    val pattern = getPattern()\n    val generatorName = chooseGenerator()\n    println(\""Please input the width of the resulting picture:\"")\n    val width = safeReadLine().toInt()\n    println(\""Please input the height of the resulting picture:\"")\n    val height = safeReadLine().toInt()\n\n    println(\""The pattern:$newLineSymbol${pattern.trimIndent()}\"")\n\n    println(\""The generated image:\"")\n    println(applyGenerator(pattern, generatorName, width, height))\n}\n""},{""name"":""src/main/kotlin/Patterns.kt"",""text"":""val ball = \""\""\""                                                       \n  ○\n\""\""\"".trimIndent()\n\nval rhombus = \""\""\""\n    X\n   / \\\n   \\ /\n    X\n\""\""\"".trimIndent()\n\nval vase = \""\""\""  \n  ____   \n /    \\\n/ /  \\ \\\n\\ \\__/ /\n \\____/\n\""\""\"".trimIndent()\n\nval robot = \""\""\""     \n+---+---+\n| o   o |\n|   ^   |\n|  ---  |\n+---+---+\n\""\""\"".trimIndent()\n\nval cube = \""\""\""     \n   .+------+\n .' |    .'|\n+---+--+'  |\n|   |  |   |\n|  ,+--+---+\n|.'    | .' \n+------+'\n\""\""\"".trimIndent()\n\nval allPatternsMap = mapOf(\n    \""ball\"" to ball,\n    \""rhombus\"" to rhombus,\n    \""vase\"" to vase,\n    \""robot\"" to robot,\n    \""cube\"" to cube,\n)\n""},{""name"":""src/main/kotlin/PreDefinedSymbols.kt"",""text"":""@file:Suppress(\""MayBeConst\"")\n\nval separator = ' '\nval newLineSymbol = System.lineSeparator()\n\nfun getPatternWidth(pattern: String) = pattern.lines().maxOfOrNull { it.length } ?: 0\n\nfun getPatternByName(name: String) = allPatternsMap[name]\n\nfun allPatterns() = allPatternsMap.keys\n""},{""name"":""test/CanvasGenerator.kt"",""text"":""""},{""name"":""test/CanvasWithGapsGenerator.kt"",""text"":""""},{""name"":""test/Helpers.kt"",""text"":""""},{""name"":""test/PatternsGeneratorTestsUtils.kt"",""text"":""""},{""name"":""test/Tests.kt"",""text"":""""}]",0
FinishTheApp,LastPush,Introduction,2023-06-27 17:34:45.234567,wrong,1,"[{""name"":""src/main/kotlin/Main.kt"",""text"":""fun fillPatternRow(patternRow: String, patternWidth: Int) = if (patternRow.length <= patternWidth) {\n    val filledSpace = \""$separator\"".repeat(patternWidth - patternRow.length)\n    \""$patternRow$filledSpace \""\n} else {\n    error(\""patternRow length > patternWidth, please check the input!\"")\n}\n\nfun getPatternHeight(pattern: String) = pattern.lines().size\n\nfun repeatHorizontally(pattern: String, n: Int, patternWidth: Int): String {\n    val pictureRows = pattern.lines()\n    val sb = StringBuilder()\n    for (row in pictureRows) {\n        val currentRow = fillPatternRow(row, patternWidth)\n        sb.append(currentRow.repeat(n))\n        sb.append(newLineSymbol)\n    }\n    return sb.toString()\n}\n\nfun dropTopFromLine(line: String, width: Int, patternHeight: Int, patternWidth: Int): String {\n    val nToDrop = if (patternHeight > 1) {\n        patternWidth * width + newLineSymbol.length\n    } else {\n        0\n    }\n    val newPattern = line.removeSuffix(newLineSymbol).drop(nToDrop)\n    return \""$newPattern$newLineSymbol\""\n}\n\nfun baseGenerator(firstLine: String, secondLine: String, height: Int): String {\n    val sb = StringBuilder()\n    sb.append(firstLine)\n    return when {\n        height < 1 -> \""\""\n        height == 1 -> sb.toString()\n        else -> {\n            sb.append(secondLine)\n            sb.append(repeatVertically(firstLine, secondLine, height))\n            sb.toString()\n        }\n    }\n}\n\nfun repeatVertically(firstLine: String, secondLine: String, height: Int): String {\n    val currentHeight = makeEvenNumber(height) / 2 - 1\n    val pattern = \""$firstLine$secondLine\"".repeat(currentHeight)\n    return if (height % 2 == 0) {\n        pattern\n    } else {\n        \""$pattern$firstLine\""\n    }\n}\n\nfun makeEvenNumber(number: Int) = if (number % 2 == 0) {\n    number\n} else {\n    number - 1\n}\n\nfun canvasGenerator(pattern: String, width: Int, height: Int): String {\n    val patternWidth = getPatternWidth(pattern)\n    val patternHeight = getPatternHeight(pattern)\n    val repeatedPattern = repeatHorizontally(pattern, width, patternWidth)\n    val dropped = dropTopFromLine(repeatedPattern, width, patternHeight, patternWidth)\n    return \""$repeatedPattern${baseGenerator(dropped, dropped, height - 1)}\""\n}\n\nfun addEmptyWindow(patternRow: String, patternWidth: Int, toAddAfter: Boolean = false): String {\n    val separator = \""$separator\"".repeat(patternWidth)\n    return if (toAddAfter) {\n        \""$patternRow$separator\""\n    } else {\n        \""$separator$patternRow\""\n    }\n}\n\nfun isEmpty(pattern: String) = pattern == \""\""\n\nfun repeatHorizontallyWithGaps(pattern: String, n: Int, toAddSeparatorAfter: Boolean): String {\n    val pictureRows = pattern.lines()\n    val patternWidth = getPatternWidth(pattern)\n    val sb = StringBuilder()\n    for (row in pictureRows) {\n        val currentRow = fillPatternRow(row, patternWidth)\n\n        val currentRwSb = StringBuilder()\n        val currentWidth = makeEvenNumber(n) / 2\n        val patternToRepeat = addEmptyWindow(currentRow, patternWidth, toAddSeparatorAfter).repeat(currentWidth)\n        if (isEmpty(patternToRepeat)) {\n            currentRwSb.append(currentRow)\n        } else {\n            currentRwSb.append(patternToRepeat)\n        }\n        if (n % 2 != 0 && !isEmpty(patternToRepeat)) {\n            currentRwSb.append(patternToRepeat.dropLast(patternToRepeat.length - currentRow.length))\n        }\n        sb.append(currentRwSb.toString())\n        sb.append(newLineSymbol)\n    }\n    return sb.toString()\n}\n\nfun canvasWithGapsGenerator(pattern: String, width: Int, height: Int): String {\n    val firstLine = repeatHorizontallyWithGaps(pattern, width, true)\n    val secondLine = repeatHorizontallyWithGaps(pattern, width, false)\n    return baseGenerator(firstLine, secondLine, height)\n}\n\nfun applyGenerator(pattern: String, generatorName: String, width: Int, height: Int) = when (generatorName) {\n    \""canvas\"" -> canvasGenerator(pattern.trimIndent(), width, height)\n    \""canvasGaps\"" -> canvasWithGapsGenerator(pattern.trimIndent(), width, height)\n    else -> error(\""Unsupported generator: $generatorName\"")\n}\n\nfun getPattern(): String {\n    println(\n        \""Do you want to use a pre-defined pattern or a custom one? \"" +\n                \""Please input 'yes' for a pre-defined pattern or 'no' for a custom one\""\n    )\n    do {\n        when (safeReadLine()) {\n            \""yes\"" -> {\n                return choosePattern()\n            }\n            \""no\"" -> {\n                println(\""Please, input a custom picture\"")\n                return safeReadLine()\n            }\n            else -> println(\""Please input 'yes' or 'no'\"")\n        }\n    } while (true)\n}\n\nfun choosePattern(): String {\n    do {\n        println(\""Please choose a pattern. The possible options: ${allPatterns().joinToString(\"", \"")}\"")\n        val name = safeReadLine()\n        val pattern = getPatternByName(name)\n        pattern?.let {\n            return pattern\n        }\n    } while (true)\n}\n\nfun chooseGenerator(): String {\n    var toContinue = true\n    var generator = \""\""\n    println(\""Please choose the generator: 'canvas' or 'canvasGaps'.\"")\n    do {\n        when (val input = safeReadLine()) {\n            \""canvas\"", \""canvasGaps\"" -> {\n                toContinue = false\n                generator = input\n            }\n            else -> println(\""Please, input 'canvas' or 'canvasGaps'\"")\n        }\n    } while (toContinue)\n    return generator\n}\n\nfun safeReadLine(): String = readlnOrNull() ?: error(\""Your input is incorrect, sorry\"")\n\nfun main() {\n    val pattern = getPattern()\n    val generatorName = chooseGenerator()\n    println(\""Please input the width of the resulting picture:\"")\n    val width = safeReadLine().toInt()\n    println(\""Please input the height of the resulting picture:\"")\n    val height = safeReadLine().toInt()\n\n    println(\""The pattern:$newLineSymbol${pattern.trimIndent()}\"")\n\n    println(\""The generated image:\"")\n    println(applyGenerator(pattern, generatorName, width, height))\n}\n""},{""name"":""src/main/kotlin/Patterns.kt"",""text"":""val ball = \""\""\""                                                       \n  ○\n\""\""\"".trimIndent()\n\nval rhombus = \""\""\""\n    X\n   / \\\n   \\ /\n    X\n\""\""\"".trimIndent()\n\nval vase = \""\""\""  \n  ____   \n /    \\\n/ /  \\ \\\n\\ \\__/ /\n \\____/\n\""\""\"".trimIndent()\n\nval robot = \""\""\""     \n+---+---+\n| o   o |\n|   ^   |\n|  ---  |\n+---+---+\n\""\""\"".trimIndent()\n\nval cube = \""\""\""     \n   .+------+\n .' |    .'|\n+---+--+'  |\n|   |  |   |\n|  ,+--+---+\n|.'    | .' \n+------+'\n\""\""\"".trimIndent()\n\nval allPatternsMap = mapOf(\n    \""ball\"" to ball,\n    \""rhombus\"" to rhombus,\n    \""vase\"" to vase,\n    \""robot\"" to robot,\n    \""cube\"" to cube,\n)\n""},{""name"":""src/main/kotlin/PreDefinedSymbols.kt"",""text"":""@file:Suppress(\""MayBeConst\"")\n\nval separator = ' '\nval newLineSymbol = System.lineSeparator()\n\nfun getPatternWidth(pattern: String) = pattern.lines().maxOfOrNull { it.length } ?: 0\n\nfun getPatternByName(name: String) = allPatternsMap[name]\n\nfun allPatterns() = allPatternsMap.keys\n""},{""name"":""test/CanvasGenerator.kt"",""text"":""""},{""name"":""test/CanvasWithGapsGenerator.kt"",""text"":""""},{""name"":""test/Helpers.kt"",""text"":""""},{""name"":""test/PatternsGeneratorTestsUtils.kt"",""text"":""""},{""name"":""test/Tests.kt"",""text"":""""}]",1
FinishTheGame,AlmostDone,Introduction,2023-06-27 18:32:23.345678,wrong,1,"[{""name"":""test/Tests.kt"",""text"":""""},{""name"":""src/main/kotlin/PreDefinedSymbols.kt"",""text"":""@file:Suppress(\""MayBeConst\"")\n\nval borderSymbol = '#'\nval separator = ' '\nval newLineSymbol = System.lineSeparator()\n\nfun getPictureWidth(picture: String) = picture.lines().maxOfOrNull { it.length } ?: 0\n\nfun getPictureByName(name: String) = allImages[name]\n\nfun allPictures() = allImages.keys\n""},{""name"":""src/main/kotlin/Main.kt"",""text"":""fun trimPicture(picture: String) = picture.trimIndent()\n\nfun applyBordersFilter(picture: String): String {\n    val pictureRows = picture.lines()\n    val pictureWidth = getPictureWidth(picture)\n    val horizontalBorder = \""$borderSymbol\"".repeat(pictureWidth + 4)\n\n    val sb = StringBuilder()\n    sb.append(\""$horizontalBorder$newLineSymbol\"")\n    for (row in pictureRows) {\n        sb.append(\""$borderSymbol$separator$row\"")\n        if (row.length < pictureWidth) {\n            sb.append(\""$separator\"".repeat(pictureWidth - row.length))\n        }\n        sb.append(\""$separator$borderSymbol$newLineSymbol\"")\n    }\n    sb.append(\""$horizontalBorder$newLineSymbol\"")\n    return sb.toString()\n}\n\nfun applySquaredFilter(picture: String): String {\n    val bordered = applyBordersFilter(picture.trimIndent())\n    val pictureRows = bordered.lines()\n\n    val sbTop = StringBuilder()\n    val sbBottom = StringBuilder()\n    for (index in pictureRows.indices) {\n        val newRow = pictureRows[index].repeat(2)\n        when (index) {\n            0 -> sbTop.append(\""$newRow$newLineSymbol\"")\n            pictureRows.indices.last -> sbBottom.append(newRow)\n            else -> {\n                sbTop.append(\""$newRow$newLineSymbol\"")\n                sbBottom.append(\""$newRow$newLineSymbol\"")\n            }\n        }\n    }\n    return \""$sbTop$sbBottom\""\n}\n\nfun applyFilter(picture: String, filter: String): String {\n    val trimmedPicture = trimPicture(picture)\n    return when(filter) {\n        \""borders\"" -> applyBordersFilter(trimmedPicture)\n        \""squared\"" -> applySquaredFilter(trimmedPicture)\n        else -> error(\""Unexpected filter\"")\n    }\n}\n\nfun safeReadLine(): String = readlnOrNull() ?: error(\""Your input is incorrect, sorry\"")\n\nfun chooseFilter(): String {\n    var toContinue = true\n    var filter = \""\""\n    println(\""Please choose the filter: 'borders' or 'squared'.\"")\n    do {\n        when (val input = safeReadLine()) {\n            \""borders\"", \""squared\"" -> {\n                toContinue = false\n                filter = input\n            }\n            else -> println(\""Please input 'borders' or 'squared'\"")\n        }\n    } while (toContinue)\n    return filter\n}\n\nfun choosePicture(): String {\n    do {\n        println(\""Please, choose a picture. The possible options: ${allPictures().joinToString(\"", \"")}\"")\n        val name = safeReadLine()\n        val picture = getPictureByName(name)\n        picture?.let {\n            return picture\n        }\n    } while (true)\n}\n\nfun getPicture(): String {\n    println(\""Do you want to use a pre-defined picture or use a custom one? \"" +\n            \""Please, input 'yes' for a pre-defined image or 'no' for a custom one\"")\n    do {\n        when (safeReadLine()) {\n            \""yes\"" -> {\n                return choosePicture()\n            }\n            \""no\"" -> {\n                println(\""Please, input a custom picture\"")\n                return safeReadLine()\n            }\n            else -> println(\""Please, input 'yes' or 'no'\"")\n        }\n     while (true)\n}\n\nfun photoshop() {\n    val picture = getPicture()\n    val filter = chooseFilter()\n\n    println(\""The old image:$newLineSymbol${trimPicture(picture)}\"")\n\n    println(\""The transformed picture:\"")\n    println(applyFilter(picture, filter))\n}\n\nfun main() {\n    photoshop()\n}\n""},{""name"":""src/main/kotlin/Images.kt"",""text"":""@file:Suppress(\""MayBeConst\"")\n\nval spongeBob = \""\""\""\n    ┈┈╱▔▔▔▔▔▔▔▔▔▔▔▏ \n    ┈╱╭▏╮╭┻┻╮╭┻┻╮╭▏ \n    ▕╮╰▏╯┃╭╮┃┃╭╮┃╰▏ \n    ▕╯┈▏┈┗┻┻┛┗┻┻┻╮▏ \n    ▕╭╮▏╮┈┈┈┈┏━━━╯▏\n    ▕╰╯▏╯╰┳┳┳┳┳┳╯╭▏ \n    ▕┈╭▏╭╮┃┗┛┗┛┃┈╰▏ \n    ▕┈╰▏╰╯╰━━━━╯┈┈▏\n\""\""\""\n\nval simba = \""\""\""\n    ┈╱▔╲▂╱╱╱╱▂╱▔╲┈┈\n    ▕▔╲┈╱▔╲┈┈╱╲╱▔▏┈\n    ▕▏┈▏╱▉╲┈┈╱▉╲▕▏┈\n    ┈╲▃▏▔▔▔╲▂▂▂▕╱┈┈\n    ┈┈┈▏┊┊┳┊╲▂╱┳▏┈┈\n    ┈┈▕╲▂┊╰━━┻━╱┈┈┈\n    ┈┈╱┈┈▔▔╲▂▂╱╲┈┈┈\n\""\""\""\n\nval brianGriffin = \""\""\""\n    ╭━┳━╭━╭━╮╮\n    ┃┈┈┈┣▅╋▅┫┃\n    ┃┈┃┈╰━╰━━━━━━╮\n    ╰┳╯┈┈┈┈┈┈┈┈┈◢▉◣\n    ╲┃┈┈┈┈┈┈┈┈┈┈▉▉▉\n    ╲┃┈┈┈┈┈┈┈┈┈┈◥▉◤\n    ╲┃┈┈┈┈╭━┳━━━━╯\n    ╲┣━━━━━━┫\n\""\""\""\n\nval cat = \""\""\""\n    ┈┈╱╲┈┈┈╱╲┈┈╭━╮┈\n    ┈╱╱╲╲__╱╱╲╲╰╮┃┈\n    ┈▏┏┳╮┈╭┳┓▕┈┈┃┃┈\n    ┈▏╰┻┛▼┗┻╯▕┈┈┃┃┈\n    ┈╲┈┈╰┻╯┈┈╱▔▔┈┃┈\n    ┈┈╰━┳━━━╯┈┈┈┈┃┈\n    ┈┈┈┈┃┏┓┣━━┳┳┓┃┈\n    ┈┈┈┈┗┛┗┛┈┈┗┛┗┛┈\n\""\""\""\n\nval pig = \""\""\""\n    ┈┏━╮╭━┓┈╭━━━━╮\n    ┈┃┏┗┛┓┃╭┫    ┃\n    ┈╰┓▋▋┏╯╯╰━━━━╯\n    ╭━┻╮╲┗━━━━╮╭╮┈\n    ┃▎▎┃╲╲╲╲╲╲┣━╯┈\n    ╰━┳┻▅╯╲╲╲╲┃┈┈┈\n    ┈┈╰━┳┓┏┳┓┏╯┈┈┈\n    ┈┈┈┈┗┻┛┗┻┛┈┈┈┈\n\""\""\""\n\nval fox = \""\""\""\n    ╱▏┈┈┈┈┈┈▕╲▕╲┈┈┈\n    ▏▏┈┈┈┈┈┈▕▏▔▔╲┈┈\n    ▏╲┈┈┈┈┈┈╱┈▔┈▔╲┈\n    ╲▏▔▔▔▔▔▔╯╯╰┳━━▀\n    ┈▏╯╯╯╯╯╯╯╯╱┃┈┈┈\n    ┈┃┏┳┳━━━┫┣┳┃┈┈┈\n    ┈┃┃┃┃┈┈┈┃┃┃┃┈┈┈\n    ┈┗┛┗┛┈┈┈┗┛┗┛┈┈┈\n\""\""\""\n\nval monkey = \""\""\""\n    ┊┊┊╱▔▔▔▔▔╲┊┊┊┊┊\n    ┊┊╱┈┈╱▔╲╲╲▏┊┊┊┊\n    ┊╱┈╭━━╱▔▔▔▔╲━━╮\n    ┊▏┈┃▔▔▏╭▅╭▅▕▔▔┃\n    ┊▏┈╰━╱┈╭┳┳╮┳╲━╯\n    ┊╲┈┈╲▏╭━━━━╯▕┊┊\n    ┊┊╲┈┈╲▂▂▂▂▂▂╱▔╲\n\""\""\""\n\nval elephant = \""\""\""\n    ┈┈┈┈╱▔▔▔▔▔╲┈╱▔╲\n    ┈┈┈┈▏┈┈▏╭╮▕┈▏╳▕\n    ┈┈┈┈▏┈┈▏┈┈▕┈╲▂╱\n    ┈╱▔▔╲▂╱╲▂▂┈╲▂▏▏\n    ╭▏┈┈┈┈┈┈┈▏╲▂▂╱┈\n    ┃▏┈┈┈┈▏┈┈▏┈┈┈┈┈\n    ╯▏┈╲╱▔╲▅▅▏┈┈┈┈┈\n    ┈╲▅▅▏▕▔▔▔▔▏┈┈┈┈\n\""\""\""\n\nval android = \""\""\""\n    ┈┈┈╲┈┈┈┈╱\n    ┈┈┈╱▔▔▔▔╲\n    ┈┈┃┈▇┈┈▇┈┃\n    ╭╮┣━━━━━━┫╭╮\n    ┃┃┃┈┈┈┈┈┈┃┃┃\n    ╰╯┃┈┈┈┈┈┈┃╰╯\n    ┈┈╰┓┏━━┓┏╯\n    ┈┈┈╰╯┈┈╰╯\n\""\""\""\n\nval apple = \""\""\""\n    ┊┊┊┊┊┊┊╱▏┊┊┊┊┊┊\n    ┊┊┊┊┊┊▕╱┊┊┊┊┊┊┊\n    ┊┊┊╱▔▔╲┊╱▔▔╲┊┊┊\n    ┊┊▕┈┈┈┈▔┈┈┈╱┊┊┊\n    ┊┊▕┈┈┈┈┈┈┈┈╲┊┊┊\n    ┊┊┊╲┈┈┈┈┈┈┈╱┊┊┊\n    ┊┊┊┊╲▂▂▂▂▂╱┊┊┊┊\n\""\""\""\n\nval allImages = mapOf(\n    \""spongeBob\"" to spongeBob,\n    \""simba\"" to simba,\n    \""brianGriffin\"" to brianGriffin,\n    \""cat\"" to cat,\n    \""pig\"" to pig,\n    \""fox\"" to fox,\n    \""monkey\"" to monkey,\n    \""elephant\"" to elephant,\n    \""android\"" to android,\n    \""apple\"" to apple,\n)\n\n""},{""name"":""test/PhotoshopTestsUtils.kt"",""text"":""""}]",2
FinishTheGame,AlmostDone,Introduction,2023-06-27 18:45:56.456789,correct,1,"[{""name"":""test/Tests.kt"",""text"":""""},{""name"":""src/main/kotlin/PreDefinedSymbols.kt"",""text"":""@file:Suppress(\""MayBeConst\"")\n\nval borderSymbol = '#'\nval separator = ' '\nval newLineSymbol = System.lineSeparator()\n\nfun getPictureWidth(picture: String) = picture.lines().maxOfOrNull { it.length } ?: 0\n\nfun getPictureByName(name: String) = allImages[name]\n\nfun allPictures() = allImages.keys\n""},{""name"":""src/main/kotlin/Main.kt"",""text"":""fun trimPicture(picture: String) = picture.trimIndent()\n\nfun applyBordersFilter(picture: String): String {\n    val pictureRows = picture.lines()\n    val pictureWidth = getPictureWidth(picture)\n    val horizontalBorder = \""$borderSymbol\"".repeat(pictureWidth + 4)\n\n    val sb = StringBuilder()\n    sb.append(\""$horizontalBorder$newLineSymbol\"")\n    for (row in pictureRows) {\n        sb.append(\""$borderSymbol$separator$row\"")\n        if (row.length < pictureWidth) {\n            sb.append(\""$separator\"".repeat(pictureWidth - row.length))\n        }\n        sb.append(\""$separator$borderSymbol$newLineSymbol\"")\n    }\n    sb.append(\""$horizontalBorder$newLineSymbol\"")\n    return sb.toString()\n}\n\nfun applySquaredFilter(picture: String): String {\n    val bordered = applyBordersFilter(picture.trimIndent())\n    val pictureRows = bordered.lines()\n\n    val sbTop = StringBuilder()\n    val sbBottom = StringBuilder()\n    for (index in pictureRows.indices) {\n        val newRow = pictureRows[index].repeat(2)\n        when (index) {\n            0 -> sbTop.append(\""$newRow$newLineSymbol\"")\n            pictureRows.indices.last -> sbBottom.append(newRow)\n            else -> {\n                sbTop.append(\""$newRow$newLineSymbol\"")\n                sbBottom.append(\""$newRow$newLineSymbol\"")\n            }\n        }\n    }\n    return \""$sbTop$sbBottom\""\n}\n\nfun applyFilter(picture: String, filter: String): String {\n    val trimmedPicture = trimPicture(picture)\n    return when(filter) {\n        \""borders\"" -> applyBordersFilter(trimmedPicture)\n        \""squared\"" -> applySquaredFilter(trimmedPicture)\n        else -> error(\""Unexpected filter\"")\n    }\n}\n\nfun safeReadLine(): String = readlnOrNull() ?: error(\""Your input is incorrect, sorry\"")\n\nfun chooseFilter(): String {\n    var toContinue = true\n    var filter = \""\""\n    println(\""Please choose the filter: 'borders' or 'squared'.\"")\n    do {\n        when (val input = safeReadLine()) {\n            \""borders\"", \""squared\"" -> {\n                toContinue = false\n                filter = input\n            }\n            else -> println(\""Please input 'borders' or 'squared'\"")\n        }\n    } while (toContinue)\n    return filter\n}\n\nfun choosePicture(): String {\n    do {\n        println(\""Please, choose a picture. The possible options: ${allPictures().joinToString(\"", \"")}\"")\n        val name = safeReadLine()\n        val picture = getPictureByName(name)\n        picture?.let {\n            return picture\n        }\n    } while (true)\n}\n\nfun getPicture(): String {\n    println(\""Do you want to use a pre-defined picture or use a custom one? \"" +\n            \""Please, input 'yes' for a pre-defined image or 'no' for a custom one\"")\n    do {\n        when (safeReadLine()) {\n            \""yes\"" -> {\n                return choosePicture()\n            }\n            \""no\"" -> {\n                println(\""Please, input a custom picture\"")\n                return safeReadLine()\n            }\n            else -> println(\""Please, input 'yes' or 'no'\"")\n        }\n    } while (true)\n}\n\nfun photoshop() {\n    val picture = getPicture()\n    val filter = chooseFilter()\n\n    println(\""The old image:$newLineSymbol${trimPicture(picture)}\"")\n\n    println(\""The transformed picture:\"")\n    println(applyFilter(picture, filter))\n}\n\nfun main() {\n    photoshop()\n}\n""},{""name"":""src/main/kotlin/Images.kt"",""text"":""@file:Suppress(\""MayBeConst\"")\n\nval spongeBob = \""\""\""\n    ┈┈╱▔▔▔▔▔▔▔▔▔▔▔▏ \n    ┈╱╭▏╮╭┻┻╮╭┻┻╮╭▏ \n    ▕╮╰▏╯┃╭╮┃┃╭╮┃╰▏ \n    ▕╯┈▏┈┗┻┻┛┗┻┻┻╮▏ \n    ▕╭╮▏╮┈┈┈┈┏━━━╯▏\n    ▕╰╯▏╯╰┳┳┳┳┳┳╯╭▏ \n    ▕┈╭▏╭╮┃┗┛┗┛┃┈╰▏ \n    ▕┈╰▏╰╯╰━━━━╯┈┈▏\n\""\""\""\n\nval simba = \""\""\""\n    ┈╱▔╲▂╱╱╱╱▂╱▔╲┈┈\n    ▕▔╲┈╱▔╲┈┈╱╲╱▔▏┈\n    ▕▏┈▏╱▉╲┈┈╱▉╲▕▏┈\n    ┈╲▃▏▔▔▔╲▂▂▂▕╱┈┈\n    ┈┈┈▏┊┊┳┊╲▂╱┳▏┈┈\n    ┈┈▕╲▂┊╰━━┻━╱┈┈┈\n    ┈┈╱┈┈▔▔╲▂▂╱╲┈┈┈\n\""\""\""\n\nval brianGriffin = \""\""\""\n    ╭━┳━╭━╭━╮╮\n    ┃┈┈┈┣▅╋▅┫┃\n    ┃┈┃┈╰━╰━━━━━━╮\n    ╰┳╯┈┈┈┈┈┈┈┈┈◢▉◣\n    ╲┃┈┈┈┈┈┈┈┈┈┈▉▉▉\n    ╲┃┈┈┈┈┈┈┈┈┈┈◥▉◤\n    ╲┃┈┈┈┈╭━┳━━━━╯\n    ╲┣━━━━━━┫\n\""\""\""\n\nval cat = \""\""\""\n    ┈┈╱╲┈┈┈╱╲┈┈╭━╮┈\n    ┈╱╱╲╲__╱╱╲╲╰╮┃┈\n    ┈▏┏┳╮┈╭┳┓▕┈┈┃┃┈\n    ┈▏╰┻┛▼┗┻╯▕┈┈┃┃┈\n    ┈╲┈┈╰┻╯┈┈╱▔▔┈┃┈\n    ┈┈╰━┳━━━╯┈┈┈┈┃┈\n    ┈┈┈┈┃┏┓┣━━┳┳┓┃┈\n    ┈┈┈┈┗┛┗┛┈┈┗┛┗┛┈\n\""\""\""\n\nval pig = \""\""\""\n    ┈┏━╮╭━┓┈╭━━━━╮\n    ┈┃┏┗┛┓┃╭┫    ┃\n    ┈╰┓▋▋┏╯╯╰━━━━╯\n    ╭━┻╮╲┗━━━━╮╭╮┈\n    ┃▎▎┃╲╲╲╲╲╲┣━╯┈\n    ╰━┳┻▅╯╲╲╲╲┃┈┈┈\n    ┈┈╰━┳┓┏┳┓┏╯┈┈┈\n    ┈┈┈┈┗┻┛┗┻┛┈┈┈┈\n\""\""\""\n\nval fox = \""\""\""\n    ╱▏┈┈┈┈┈┈▕╲▕╲┈┈┈\n    ▏▏┈┈┈┈┈┈▕▏▔▔╲┈┈\n    ▏╲┈┈┈┈┈┈╱┈▔┈▔╲┈\n    ╲▏▔▔▔▔▔▔╯╯╰┳━━▀\n    ┈▏╯╯╯╯╯╯╯╯╱┃┈┈┈\n    ┈┃┏┳┳━━━┫┣┳┃┈┈┈\n    ┈┃┃┃┃┈┈┈┃┃┃┃┈┈┈\n    ┈┗┛┗┛┈┈┈┗┛┗┛┈┈┈\n\""\""\""\n\nval monkey = \""\""\""\n    ┊┊┊╱▔▔▔▔▔╲┊┊┊┊┊\n    ┊┊╱┈┈╱▔╲╲╲▏┊┊┊┊\n    ┊╱┈╭━━╱▔▔▔▔╲━━╮\n    ┊▏┈┃▔▔▏╭▅╭▅▕▔▔┃\n    ┊▏┈╰━╱┈╭┳┳╮┳╲━╯\n    ┊╲┈┈╲▏╭━━━━╯▕┊┊\n    ┊┊╲┈┈╲▂▂▂▂▂▂╱▔╲\n\""\""\""\n\nval elephant = \""\""\""\n    ┈┈┈┈╱▔▔▔▔▔╲┈╱▔╲\n    ┈┈┈┈▏┈┈▏╭╮▕┈▏╳▕\n    ┈┈┈┈▏┈┈▏┈┈▕┈╲▂╱\n    ┈╱▔▔╲▂╱╲▂▂┈╲▂▏▏\n    ╭▏┈┈┈┈┈┈┈▏╲▂▂╱┈\n    ┃▏┈┈┈┈▏┈┈▏┈┈┈┈┈\n    ╯▏┈╲╱▔╲▅▅▏┈┈┈┈┈\n    ┈╲▅▅▏▕▔▔▔▔▏┈┈┈┈\n\""\""\""\n\nval android = \""\""\""\n    ┈┈┈╲┈┈┈┈╱\n    ┈┈┈╱▔▔▔▔╲\n    ┈┈┃┈▇┈┈▇┈┃\n    ╭╮┣━━━━━━┫╭╮\n    ┃┃┃┈┈┈┈┈┈┃┃┃\n    ╰╯┃┈┈┈┈┈┈┃╰╯\n    ┈┈╰┓┏━━┓┏╯\n    ┈┈┈╰╯┈┈╰╯\n\""\""\""\n\nval apple = \""\""\""\n    ┊┊┊┊┊┊┊╱▏┊┊┊┊┊┊\n    ┊┊┊┊┊┊▕╱┊┊┊┊┊┊┊\n    ┊┊┊╱▔▔╲┊╱▔▔╲┊┊┊\n    ┊┊▕┈┈┈┈▔┈┈┈╱┊┊┊\n    ┊┊▕┈┈┈┈┈┈┈┈╲┊┊┊\n    ┊┊┊╲┈┈┈┈┈┈┈╱┊┊┊\n    ┊┊┊┊╲▂▂▂▂▂╱┊┊┊┊\n\""\""\""\n\nval allImages = mapOf(\n    \""spongeBob\"" to spongeBob,\n    \""simba\"" to simba,\n    \""brianGriffin\"" to brianGriffin,\n    \""cat\"" to cat,\n    \""pig\"" to pig,\n    \""fox\"" to fox,\n    \""monkey\"" to monkey,\n    \""elephant\"" to elephant,\n    \""android\"" to android,\n    \""apple\"" to apple,\n)\n\n""},{""name"":""test/PhotoshopTestsUtils.kt"",""text"":""""}]",3
FinishTheGame,AlmostDone,Introduction,2023-06-27 19:19:19.123456,wrong,2,"[{""name"":""test/Tests.kt"",""text"":""""},{""name"":""src/main/kotlin/PreDefinedSymbols.kt"",""text"":""@file:Suppress(\""MayBeConst\"")\n\nval borderSymbol = '#'\nval separator = ' '\nval newLineSymbol = System.lineSeparator()\n\nfun getPictureWidth(picture: String) = picture.lines().maxOfOrNull { it.length } ?: 0\n\nfun getPictureByName(name: String) = allImages[name]\n\nfun allPictures() = allImages.keys\n""},{""name"":""src/main/kotlin/Main.kt"",""text"":""fun trimPicture(picture: String) = picture.trimIndent()\n\nfun applyBordersFilter(picture: String): String {\n    val pictureRows = picture.lines()\n    val pictureWidth = getPictureWidth(picture)\n    val horizontalBorder = \""$borderSymbol\"".repeat(pictureWidth + 4)\n\n    val sb = StringBuilder()\n    sb.append(\""$horizontalBorder$newLineSymbol\"")\n    for (row in pictureRows) {\n        sb.append(\""$borderSymbol$separator$row\"")\n        if (row.length < pictureWidth) {\n            sb.append(\""$separator\"".repeat(pictureWidth - row.length))\n        }\n        sb.append(\""$separator$borderSymbol$newLineSymbol\"")\n    }\n    sb.append(\""$horizontalBorder$newLineSymbol\"")\n    return sb.toString()\n}\n\nfun applySquaredFilter(picture: String): String {\n    val bordered = applyBordersFilter(picture.trimIndent())\n    val pictureRows = bordered.lines()\n\n    val sbTop = StringBuilder()\n    val sbBottom = StringBuilder()\n    for (index in pictureRows.indices) {\n        val newRow = pictureRows[index].repeat(2)\n        when (index) {\n            0 -> sbTop.append(\""$newRow$newLineSymbol\"")\n            pictureRows.indices.last -> sbBottom.append(newRow)\n            else -> {\n                sbTop.append(\""$newRow$newLineSymbol\"")\n                sbBottom.append(\""$newRow$newLineSymbol\"")\n            }\n        }\n    }\n    return \""$sbTop$sbBottom\""\n}\n\nfun applyFilter(picture: String, filter: String): String {\n    val trimmedPicture = trimPicture(picture)\n    return when(filter) {\n        \""borders\"" -> applyBordersFilter(trimmedPicture)\n        \""squared\"" -> applySquaredFilter(trimmedPicture)\n        else -> error(\""Unexpected filter\"")\n    }\n}\n\nfun safeReadLine(): String = readlnOrNull() ?: error(\""Your input is incorrect, sorry\"")\n\nfun chooseFilter(): String {\n    var toContinue = true\n    var filter = \""\""\n    println(\""Please choose the filter: 'borders' or 'squared'.\"")\n    do {\n        when (val input = safeReadLine()) {\n            \""borders\"", \""squared\"" -> {\n                toContinue = false\n                filter = input\n            }\n            else -> println(\""Please input 'borders' or 'squared'\"")\n        }\n    } while (toContinue)\n    return filter\n}\n\nfun choosePicture(): String {\n    do {\n        println(\""Please, choose a picture. The possible options: ${allPictures().joinToString(\"", \"")}\"")\n        val name = safeReadLine()\n        val picture = getPictureByName(name)\n        picture?.let {\n            return picture\n        }\n    } while (true)\n}\n\nfun getPicture(): String {\n    println(\""Do you want to use a pre-defined picture or use a custom one? \"" +\n            \""Please, input 'yes' for a pre-defined image or 'no' for a custom one\"")\n    do {\n        when (safeReadLine()) {\n            \""yes\"" -> {\n                return choosePicture()\n            }\n            \""no\"" -> {\n                println(\""Please, input a custom picture\"")\n                return safeReadLine()\n            }\n            else -> println(\""Please, input 'yes' or 'no'\"")\n        }\n     while (true)\n}\n\nfun photoshop() {\n    val picture = getPicture()\n    val filter = chooseFilter()\n\n    println(\""The old image:$newLineSymbol${trimPicture(picture)}\"")\n\n    println(\""The transformed picture:\"")\n    println(applyFilter(picture, filter))\n}\n\nfun main() {\n    photoshop()\n}\n""},{""name"":""src/main/kotlin/Images.kt"",""text"":""@file:Suppress(\""MayBeConst\"")\n\nval spongeBob = \""\""\""\n    ┈┈╱▔▔▔▔▔▔▔▔▔▔▔▏ \n    ┈╱╭▏╮╭┻┻╮╭┻┻╮╭▏ \n    ▕╮╰▏╯┃╭╮┃┃╭╮┃╰▏ \n    ▕╯┈▏┈┗┻┻┛┗┻┻┻╮▏ \n    ▕╭╮▏╮┈┈┈┈┏━━━╯▏\n    ▕╰╯▏╯╰┳┳┳┳┳┳╯╭▏ \n    ▕┈╭▏╭╮┃┗┛┗┛┃┈╰▏ \n    ▕┈╰▏╰╯╰━━━━╯┈┈▏\n\""\""\""\n\nval simba = \""\""\""\n    ┈╱▔╲▂╱╱╱╱▂╱▔╲┈┈\n    ▕▔╲┈╱▔╲┈┈╱╲╱▔▏┈\n    ▕▏┈▏╱▉╲┈┈╱▉╲▕▏┈\n    ┈╲▃▏▔▔▔╲▂▂▂▕╱┈┈\n    ┈┈┈▏┊┊┳┊╲▂╱┳▏┈┈\n    ┈┈▕╲▂┊╰━━┻━╱┈┈┈\n    ┈┈╱┈┈▔▔╲▂▂╱╲┈┈┈\n\""\""\""\n\nval brianGriffin = \""\""\""\n    ╭━┳━╭━╭━╮╮\n    ┃┈┈┈┣▅╋▅┫┃\n    ┃┈┃┈╰━╰━━━━━━╮\n    ╰┳╯┈┈┈┈┈┈┈┈┈◢▉◣\n    ╲┃┈┈┈┈┈┈┈┈┈┈▉▉▉\n    ╲┃┈┈┈┈┈┈┈┈┈┈◥▉◤\n    ╲┃┈┈┈┈╭━┳━━━━╯\n    ╲┣━━━━━━┫\n\""\""\""\n\nval cat = \""\""\""\n    ┈┈╱╲┈┈┈╱╲┈┈╭━╮┈\n    ┈╱╱╲╲__╱╱╲╲╰╮┃┈\n    ┈▏┏┳╮┈╭┳┓▕┈┈┃┃┈\n    ┈▏╰┻┛▼┗┻╯▕┈┈┃┃┈\n    ┈╲┈┈╰┻╯┈┈╱▔▔┈┃┈\n    ┈┈╰━┳━━━╯┈┈┈┈┃┈\n    ┈┈┈┈┃┏┓┣━━┳┳┓┃┈\n    ┈┈┈┈┗┛┗┛┈┈┗┛┗┛┈\n\""\""\""\n\nval pig = \""\""\""\n    ┈┏━╮╭━┓┈╭━━━━╮\n    ┈┃┏┗┛┓┃╭┫    ┃\n    ┈╰┓▋▋┏╯╯╰━━━━╯\n    ╭━┻╮╲┗━━━━╮╭╮┈\n    ┃▎▎┃╲╲╲╲╲╲┣━╯┈\n    ╰━┳┻▅╯╲╲╲╲┃┈┈┈\n    ┈┈╰━┳┓┏┳┓┏╯┈┈┈\n    ┈┈┈┈┗┻┛┗┻┛┈┈┈┈\n\""\""\""\n\nval fox = \""\""\""\n    ╱▏┈┈┈┈┈┈▕╲▕╲┈┈┈\n    ▏▏┈┈┈┈┈┈▕▏▔▔╲┈┈\n    ▏╲┈┈┈┈┈┈╱┈▔┈▔╲┈\n    ╲▏▔▔▔▔▔▔╯╯╰┳━━▀\n    ┈▏╯╯╯╯╯╯╯╯╱┃┈┈┈\n    ┈┃┏┳┳━━━┫┣┳┃┈┈┈\n    ┈┃┃┃┃┈┈┈┃┃┃┃┈┈┈\n    ┈┗┛┗┛┈┈┈┗┛┗┛┈┈┈\n\""\""\""\n\nval monkey = \""\""\""\n    ┊┊┊╱▔▔▔▔▔╲┊┊┊┊┊\n    ┊┊╱┈┈╱▔╲╲╲▏┊┊┊┊\n    ┊╱┈╭━━╱▔▔▔▔╲━━╮\n    ┊▏┈┃▔▔▏╭▅╭▅▕▔▔┃\n    ┊▏┈╰━╱┈╭┳┳╮┳╲━╯\n    ┊╲┈┈╲▏╭━━━━╯▕┊┊\n    ┊┊╲┈┈╲▂▂▂▂▂▂╱▔╲\n\""\""\""\n\nval elephant = \""\""\""\n    ┈┈┈┈╱▔▔▔▔▔╲┈╱▔╲\n    ┈┈┈┈▏┈┈▏╭╮▕┈▏╳▕\n    ┈┈┈┈▏┈┈▏┈┈▕┈╲▂╱\n    ┈╱▔▔╲▂╱╲▂▂┈╲▂▏▏\n    ╭▏┈┈┈┈┈┈┈▏╲▂▂╱┈\n    ┃▏┈┈┈┈▏┈┈▏┈┈┈┈┈\n    ╯▏┈╲╱▔╲▅▅▏┈┈┈┈┈\n    ┈╲▅▅▏▕▔▔▔▔▏┈┈┈┈\n\""\""\""\n\nval android = \""\""\""\n    ┈┈┈╲┈┈┈┈╱\n    ┈┈┈╱▔▔▔▔╲\n    ┈┈┃┈▇┈┈▇┈┃\n    ╭╮┣━━━━━━┫╭╮\n    ┃┃┃┈┈┈┈┈┈┃┃┃\n    ╰╯┃┈┈┈┈┈┈┃╰╯\n    ┈┈╰┓┏━━┓┏╯\n    ┈┈┈╰╯┈┈╰╯\n\""\""\""\n\nval apple = \""\""\""\n    ┊┊┊┊┊┊┊╱▏┊┊┊┊┊┊\n    ┊┊┊┊┊┊▕╱┊┊┊┊┊┊┊\n    ┊┊┊╱▔▔╲┊╱▔▔╲┊┊┊\n    ┊┊▕┈┈┈┈▔┈┈┈╱┊┊┊\n    ┊┊▕┈┈┈┈┈┈┈┈╲┊┊┊\n    ┊┊┊╲┈┈┈┈┈┈┈╱┊┊┊\n    ┊┊┊┊╲▂▂▂▂▂╱┊┊┊┊\n\""\""\""\n\nval allImages = mapOf(\n    \""spongeBob\"" to spongeBob,\n    \""simba\"" to simba,\n    \""brianGriffin\"" to brianGriffin,\n    \""cat\"" to cat,\n    \""pig\"" to pig,\n    \""fox\"" to fox,\n    \""monkey\"" to monkey,\n    \""elephant\"" to elephant,\n    \""android\"" to android,\n    \""apple\"" to apple,\n)\n\n""},{""name"":""test/PhotoshopTestsUtils.kt"",""text"":""""}]",4
FinishTheGame,AlmostDone,Introduction,2023-06-27 19:21:22.654321,correct,2,"[{""name"":""test/Tests.kt"",""text"":""""},{""name"":""src/main/kotlin/PreDefinedSymbols.kt"",""text"":""@file:Suppress(\""MayBeConst\"")\n\nval borderSymbol = '#'\nval separator = ' '\nval newLineSymbol = System.lineSeparator()\n\nfun getPictureWidth(picture: String) = picture.lines().maxOfOrNull { it.length } ?: 0\n\nfun getPictureByName(name: String) = allImages[name]\n\nfun allPictures() = allImages.keys\n""},{""name"":""src/main/kotlin/Main.kt"",""text"":""fun trimPicture(picture: String) = picture.trimIndent()\n\nfun applyBordersFilter(picture: String): String {\n    val pictureRows = picture.lines()\n    val pictureWidth = getPictureWidth(picture)\n    val horizontalBorder = \""$borderSymbol\"".repeat(pictureWidth + 4)\n\n    val sb = StringBuilder()\n    sb.append(\""$horizontalBorder$newLineSymbol\"")\n    for (row in pictureRows) {\n        sb.append(\""$borderSymbol$separator$row\"")\n        if (row.length < pictureWidth) {\n            sb.append(\""$separator\"".repeat(pictureWidth - row.length))\n        }\n        sb.append(\""$separator$borderSymbol$newLineSymbol\"")\n    }\n    sb.append(\""$horizontalBorder$newLineSymbol\"")\n    return sb.toString()\n}\n\nfun applySquaredFilter(picture: String): String {\n    val bordered = applyBordersFilter(picture.trimIndent())\n    val pictureRows = bordered.lines()\n\n    val sbTop = StringBuilder()\n    val sbBottom = StringBuilder()\n    for (index in pictureRows.indices) {\n        val newRow = pictureRows[index].repeat(2)\n        when (index) {\n            0 -> sbTop.append(\""$newRow$newLineSymbol\"")\n            pictureRows.indices.last -> sbBottom.append(newRow)\n            else -> {\n                sbTop.append(\""$newRow$newLineSymbol\"")\n                sbBottom.append(\""$newRow$newLineSymbol\"")\n            }\n        }\n    }\n    return \""$sbTop$sbBottom\""\n}\n\nfun applyFilter(picture: String, filter: String): String {\n    val trimmedPicture = trimPicture(picture)\n    return when(filter) {\n        \""borders\"" -> applyBordersFilter(trimmedPicture)\n        \""squared\"" -> applySquaredFilter(trimmedPicture)\n        else -> error(\""Unexpected filter\"")\n    }\n}\n\nfun safeReadLine(): String = readlnOrNull() ?: error(\""Your input is incorrect, sorry\"")\n\nfun chooseFilter(): String {\n    var toContinue = true\n    var filter = \""\""\n    println(\""Please choose the filter: 'borders' or 'squared'.\"")\n    do {\n        when (val input = safeReadLine()) {\n            \""borders\"", \""squared\"" -> {\n                toContinue = false\n                filter = input\n            }\n            else -> println(\""Please input 'borders' or 'squared'\"")\n        }\n    } while (toContinue)\n    return filter\n}\n\nfun choosePicture(): String {\n    do {\n        println(\""Please, choose a picture. The possible options: ${allPictures().joinToString(\"", \"")}\"")\n        val name = safeReadLine()\n        val picture = getPictureByName(name)\n        picture?.let {\n            return picture\n        }\n    } while (true)\n}\n\nfun getPicture(): String {\n    println(\""Do you want to use a pre-defined picture or use a custom one? \"" +\n            \""Please, input 'yes' for a pre-defined image or 'no' for a custom one\"")\n    do {\n        when (safeReadLine()) {\n            \""yes\"" -> {\n                return choosePicture()\n            }\n            \""no\"" -> {\n                println(\""Please, input a custom picture\"")\n                return safeReadLine()\n            }\n            else -> println(\""Please, input 'yes' or 'no'\"")\n        }\n    } while (true)\n}\n\nfun photoshop() {\n    val picture = getPicture()\n    val filter = chooseFilter()\n\n    println(\""The old image:$newLineSymbol${trimPicture(picture)}\"")\n\n    println(\""The transformed picture:\"")\n    println(applyFilter(picture, filter))\n}\n\nfun main() {\n    photoshop()\n}\n""},{""name"":""src/main/kotlin/Images.kt"",""text"":""@file:Suppress(\""MayBeConst\"")\n\nval spongeBob = \""\""\""\n    ┈┈╱▔▔▔▔▔▔▔▔▔▔▔▏ \n    ┈╱╭▏╮╭┻┻╮╭┻┻╮╭▏ \n    ▕╮╰▏╯┃╭╮┃┃╭╮┃╰▏ \n    ▕╯┈▏┈┗┻┻┛┗┻┻┻╮▏ \n    ▕╭╮▏╮┈┈┈┈┏━━━╯▏\n    ▕╰╯▏╯╰┳┳┳┳┳┳╯╭▏ \n    ▕┈╭▏╭╮┃┗┛┗┛┃┈╰▏ \n    ▕┈╰▏╰╯╰━━━━╯┈┈▏\n\""\""\""\n\nval simba = \""\""\""\n    ┈╱▔╲▂╱╱╱╱▂╱▔╲┈┈\n    ▕▔╲┈╱▔╲┈┈╱╲╱▔▏┈\n    ▕▏┈▏╱▉╲┈┈╱▉╲▕▏┈\n    ┈╲▃▏▔▔▔╲▂▂▂▕╱┈┈\n    ┈┈┈▏┊┊┳┊╲▂╱┳▏┈┈\n    ┈┈▕╲▂┊╰━━┻━╱┈┈┈\n    ┈┈╱┈┈▔▔╲▂▂╱╲┈┈┈\n\""\""\""\n\nval brianGriffin = \""\""\""\n    ╭━┳━╭━╭━╮╮\n    ┃┈┈┈┣▅╋▅┫┃\n    ┃┈┃┈╰━╰━━━━━━╮\n    ╰┳╯┈┈┈┈┈┈┈┈┈◢▉◣\n    ╲┃┈┈┈┈┈┈┈┈┈┈▉▉▉\n    ╲┃┈┈┈┈┈┈┈┈┈┈◥▉◤\n    ╲┃┈┈┈┈╭━┳━━━━╯\n    ╲┣━━━━━━┫\n\""\""\""\n\nval cat = \""\""\""\n    ┈┈╱╲┈┈┈╱╲┈┈╭━╮┈\n    ┈╱╱╲╲__╱╱╲╲╰╮┃┈\n    ┈▏┏┳╮┈╭┳┓▕┈┈┃┃┈\n    ┈▏╰┻┛▼┗┻╯▕┈┈┃┃┈\n    ┈╲┈┈╰┻╯┈┈╱▔▔┈┃┈\n    ┈┈╰━┳━━━╯┈┈┈┈┃┈\n    ┈┈┈┈┃┏┓┣━━┳┳┓┃┈\n    ┈┈┈┈┗┛┗┛┈┈┗┛┗┛┈\n\""\""\""\n\nval pig = \""\""\""\n    ┈┏━╮╭━┓┈╭━━━━╮\n    ┈┃┏┗┛┓┃╭┫    ┃\n    ┈╰┓▋▋┏╯╯╰━━━━╯\n    ╭━┻╮╲┗━━━━╮╭╮┈\n    ┃▎▎┃╲╲╲╲╲╲┣━╯┈\n    ╰━┳┻▅╯╲╲╲╲┃┈┈┈\n    ┈┈╰━┳┓┏┳┓┏╯┈┈┈\n    ┈┈┈┈┗┻┛┗┻┛┈┈┈┈\n\""\""\""\n\nval fox = \""\""\""\n    ╱▏┈┈┈┈┈┈▕╲▕╲┈┈┈\n    ▏▏┈┈┈┈┈┈▕▏▔▔╲┈┈\n    ▏╲┈┈┈┈┈┈╱┈▔┈▔╲┈\n    ╲▏▔▔▔▔▔▔╯╯╰┳━━▀\n    ┈▏╯╯╯╯╯╯╯╯╱┃┈┈┈\n    ┈┃┏┳┳━━━┫┣┳┃┈┈┈\n    ┈┃┃┃┃┈┈┈┃┃┃┃┈┈┈\n    ┈┗┛┗┛┈┈┈┗┛┗┛┈┈┈\n\""\""\""\n\nval monkey = \""\""\""\n    ┊┊┊╱▔▔▔▔▔╲┊┊┊┊┊\n    ┊┊╱┈┈╱▔╲╲╲▏┊┊┊┊\n    ┊╱┈╭━━╱▔▔▔▔╲━━╮\n    ┊▏┈┃▔▔▏╭▅╭▅▕▔▔┃\n    ┊▏┈╰━╱┈╭┳┳╮┳╲━╯\n    ┊╲┈┈╲▏╭━━━━╯▕┊┊\n    ┊┊╲┈┈╲▂▂▂▂▂▂╱▔╲\n\""\""\""\n\nval elephant = \""\""\""\n    ┈┈┈┈╱▔▔▔▔▔╲┈╱▔╲\n    ┈┈┈┈▏┈┈▏╭╮▕┈▏╳▕\n    ┈┈┈┈▏┈┈▏┈┈▕┈╲▂╱\n    ┈╱▔▔╲▂╱╲▂▂┈╲▂▏▏\n    ╭▏┈┈┈┈┈┈┈▏╲▂▂╱┈\n    ┃▏┈┈┈┈▏┈┈▏┈┈┈┈┈\n    ╯▏┈╲╱▔╲▅▅▏┈┈┈┈┈\n    ┈╲▅▅▏▕▔▔▔▔▏┈┈┈┈\n\""\""\""\n\nval android = \""\""\""\n    ┈┈┈╲┈┈┈┈╱\n    ┈┈┈╱▔▔▔▔╲\n    ┈┈┃┈▇┈┈▇┈┃\n    ╭╮┣━━━━━━┫╭╮\n    ┃┃┃┈┈┈┈┈┈┃┃┃\n    ╰╯┃┈┈┈┈┈┈┃╰╯\n    ┈┈╰┓┏━━┓┏╯\n    ┈┈┈╰╯┈┈╰╯\n\""\""\""\n\nval apple = \""\""\""\n    ┊┊┊┊┊┊┊╱▏┊┊┊┊┊┊\n    ┊┊┊┊┊┊▕╱┊┊┊┊┊┊┊\n    ┊┊┊╱▔▔╲┊╱▔▔╲┊┊┊\n    ┊┊▕┈┈┈┈▔┈┈┈╱┊┊┊\n    ┊┊▕┈┈┈┈┈┈┈┈╲┊┊┊\n    ┊┊┊╲┈┈┈┈┈┈┈╱┊┊┊\n    ┊┊┊┊╲▂▂▂▂▂╱┊┊┊┊\n\""\""\""\n\nval allImages = mapOf(\n    \""spongeBob\"" to spongeBob,\n    \""simba\"" to simba,\n    \""brianGriffin\"" to brianGriffin,\n    \""cat\"" to cat,\n    \""pig\"" to pig,\n    \""fox\"" to fox,\n    \""monkey\"" to monkey,\n    \""elephant\"" to elephant,\n    \""android\"" to android,\n    \""apple\"" to apple,\n)\n\n""},{""name"":""test/PhotoshopTestsUtils.kt"",""text"":""""}]",5
FinishTheApp,LastPush,Introduction,2023-06-28 10:13:34.123456,correct,1,"[{""name"":""src/main/kotlin/Main.kt"",""text"":""fun fillPatternRow(patternRow: String, patternWidth: Int) = if (patternRow.length <= patternWidth) {\n    val filledSpace = \""$separator\"".repeat(patternWidth - patternRow.length)\n    \""$patternRow$filledSpace\""\n} else {\n    error(\""patternRow length > patternWidth, please check the input!\"")\n}\n\nfun getPatternHeight(pattern: String) = pattern.lines().size\n\nfun repeatHorizontally(pattern: String, n: Int, patternWidth: Int): String {\n    val pictureRows = pattern.lines()\n    val sb = StringBuilder()\n    for (row in pictureRows) {\n        val currentRow = fillPatternRow(row, patternWidth)\n        sb.append(currentRow.repeat(n))\n        sb.append(newLineSymbol)\n    }\n    return sb.toString()\n}\n\nfun dropTopFromLine(line: String, width: Int, patternHeight: Int, patternWidth: Int): String {\n    val nToDrop = if (patternHeight > 1) {\n        patternWidth * width + newLineSymbol.length\n    } else {\n        0\n    }\n    val newPattern = line.removeSuffix(newLineSymbol).drop(nToDrop)\n    return \""$newPattern$newLineSymbol\""\n}\n\nfun baseGenerator(firstLine: String, secondLine: String, height: Int): String {\n    val sb = StringBuilder()\n    sb.append(firstLine)\n    return when {\n        height < 1 -> \""\""\n        height == 1 -> sb.toString()\n        else -> {\n            sb.append(secondLine)\n            sb.append(repeatVertically(firstLine, secondLine, height))\n            sb.toString()\n        }\n    }\n}\n\nfun repeatVertically(firstLine: String, secondLine: String, height: Int): String {\n    val currentHeight = makeEvenNumber(height) / 2 - 1\n    val pattern = \""$firstLine$secondLine\"".repeat(currentHeight)\n    return if (height % 2 == 0) {\n        pattern\n    } else {\n        \""$pattern$firstLine\""\n    }\n}\n\nfun makeEvenNumber(number: Int) = if (number % 2 == 0) {\n    number\n} else {\n    number - 1\n}\n\nfun canvasGenerator(pattern: String, width: Int, height: Int): String {\n    val patternWidth = getPatternWidth(pattern)\n    val patternHeight = getPatternHeight(pattern)\n    val repeatedPattern = repeatHorizontally(pattern, width, patternWidth)\n    val dropped = dropTopFromLine(repeatedPattern, width, patternHeight, patternWidth)\n    return \""$repeatedPattern${baseGenerator(dropped, dropped, height - 1)}\""\n}\n\nfun addEmptyWindow(patternRow: String, patternWidth: Int, toAddAfter: Boolean = false): String {\n    val separator = \""$separator\"".repeat(patternWidth)\n    return if (toAddAfter) {\n        \""$patternRow$separator\""\n    } else {\n        \""$separator$patternRow\""\n    }\n}\n\nfun isEmpty(pattern: String) = pattern == \""\""\n\nfun repeatHorizontallyWithGaps(pattern: String, n: Int, toAddSeparatorAfter: Boolean): String {\n    val pictureRows = pattern.lines()\n    val patternWidth = getPatternWidth(pattern)\n    val sb = StringBuilder()\n    for (row in pictureRows) {\n        val currentRow = fillPatternRow(row, patternWidth)\n\n        val currentRwSb = StringBuilder()\n        val currentWidth = makeEvenNumber(n) / 2\n        val patternToRepeat = addEmptyWindow(currentRow, patternWidth, toAddSeparatorAfter).repeat(currentWidth)\n        if (isEmpty(patternToRepeat)) {\n            currentRwSb.append(currentRow)\n        } else {\n            currentRwSb.append(patternToRepeat)\n        }\n        if (n % 2 != 0 && !isEmpty(patternToRepeat)) {\n            currentRwSb.append(patternToRepeat.dropLast(patternToRepeat.length - currentRow.length))\n        }\n        sb.append(currentRwSb.toString())\n        sb.append(newLineSymbol)\n    }\n    return sb.toString()\n}\n\nfun canvasWithGapsGenerator(pattern: String, width: Int, height: Int): String {\n    val firstLine = repeatHorizontallyWithGaps(pattern, width, true)\n    val secondLine = repeatHorizontallyWithGaps(pattern, width, false)\n    return baseGenerator(firstLine, secondLine, height)\n}\n\nfun applyGenerator(pattern: String, generatorName: String, width: Int, height: Int) = when (generatorName) {\n    \""canvas\"" -> canvasGenerator(pattern.trimIndent(), width, height)\n    \""canvasGaps\"" -> canvasWithGapsGenerator(pattern.trimIndent(), width, height)\n    else -> error(\""Unsupported generator: $generatorName\"")\n}\n\nfun getPattern(): String {\n    println(\n        \""Do you want to use a pre-defined pattern or a custom one? \"" +\n                \""Please input 'yes' for a pre-defined pattern or 'no' for a custom one\""\n    )\n    do {\n        when (safeReadLine()) {\n            \""yes\"" -> {\n                return choosePattern()\n            }\n            \""no\"" -> {\n                println(\""Please, input a custom picture\"")\n                return safeReadLine()\n            }\n            else -> println(\""Please input 'yes' or 'no'\"")\n        }\n    } while (true)\n}\n\nfun choosePattern(): String {\n    do {\n        println(\""Please choose a pattern. The possible options: ${allPatterns().joinToString(\"", \"")}\"")\n        val name = safeReadLine()\n        val pattern = getPatternByName(name)\n        pattern?.let {\n            return pattern\n        }\n    } while (true)\n}\n\nfun chooseGenerator(): String {\n    var toContinue = true\n    var generator = \""\""\n    println(\""Please choose the generator: 'canvas' or 'canvasGaps'.\"")\n    do {\n        when (val input = safeReadLine()) {\n            \""canvas\"", \""canvasGaps\"" -> {\n                toContinue = false\n                generator = input\n            }\n            else -> println(\""Please, input 'canvas' or 'canvasGaps'\"")\n        }\n    } while (toContinue)\n    return generator\n}\n\nfun safeReadLine(): String = readlnOrNull() ?: error(\""Your input is incorrect, sorry\"")\n\nfun main() {\n    val pattern = getPattern()\n    val generatorName = chooseGenerator()\n    println(\""Please input the width of the resulting picture:\"")\n    val width = safeReadLine().toInt()\n    println(\""Please input the height of the resulting picture:\"")\n    val height = safeReadLine().toInt()\n\n    println(\""The pattern:$newLineSymbol${pattern.trimIndent()}\"")\n\n    println(\""The generated image:\"")\n    println(applyGenerator(pattern, generatorName, width, height))\n}\n""},{""name"":""src/main/kotlin/Patterns.kt"",""text"":""val ball = \""\""\""                                                       \n  ○\n\""\""\"".trimIndent()\n\nval rhombus = \""\""\""\n    X\n   / \\\n   \\ /\n    X\n\""\""\"".trimIndent()\n\nval vase = \""\""\""  \n  ____   \n /    \\\n/ /  \\ \\\n\\ \\__/ /\n \\____/\n\""\""\"".trimIndent()\n\nval robot = \""\""\""     \n+---+---+\n| o   o |\n|   ^   |\n|  ---  |\n+---+---+\n\""\""\"".trimIndent()\n\nval cube = \""\""\""     \n   .+------+\n .' |    .'|\n+---+--+'  |\n|   |  |   |\n|  ,+--+---+\n|.'    | .' \n+------+'\n\""\""\"".trimIndent()\n\nval allPatternsMap = mapOf(\n    \""ball\"" to ball,\n    \""rhombus\"" to rhombus,\n    \""vase\"" to vase,\n    \""robot\"" to robot,\n    \""cube\"" to cube,\n)\n""},{""name"":""src/main/kotlin/PreDefinedSymbols.kt"",""text"":""@file:Suppress(\""MayBeConst\"")\n\nval separator = ' '\nval newLineSymbol = System.lineSeparator()\n\nfun getPatternWidth(pattern: String) = pattern.lines().maxOfOrNull { it.length } ?: 0\n\nfun getPatternByName(name: String) = allPatternsMap[name]\n\nfun allPatterns() = allPatternsMap.keys\n""},{""name"":""test/CanvasGenerator.kt"",""text"":""""},{""name"":""test/CanvasWithGapsGenerator.kt"",""text"":""""},{""name"":""test/Helpers.kt"",""text"":""""},{""name"":""test/PatternsGeneratorTestsUtils.kt"",""text"":""""},{""name"":""test/Tests.kt"",""text"":""""}]",6