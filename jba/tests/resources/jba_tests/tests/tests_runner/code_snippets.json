[
  {
    "name": "src/main/kotlin/Main.kt",
    "text": "fun fillPatternRow(patternRow: String, patternWidth: Int) = if (patternRow.length <= patternWidth) {\n    val filledSpace = \"$separator\".repeat(patternWidth - patternRow.length)\n    \"$patternRow$filledSpace \"\n} else {\n    error(\"patternRow length > patternWidth, please check the input!\")\n}\n\nfun getPatternHeight(pattern: String) = pattern.lines().size\n\nfun repeatHorizontally(pattern: String, n: Int, patternWidth: Int): String {\n    val pictureRows = pattern.lines()\n    val sb = StringBuilder()\n    for (row in pictureRows) {\n        val currentRow = fillPatternRow(row, patternWidth)\n        sb.append(currentRow.repeat(n))\n        sb.append(newLineSymbol)\n    }\n    return sb.toString()\n}\n\nfun dropTopFromLine(line: String, width: Int, patternHeight: Int, patternWidth: Int): String {\n    val nToDrop = if (patternHeight > 1) {\n        patternWidth * width + newLineSymbol.length\n    } else {\n        0\n    }\n    val newPattern = line.removeSuffix(newLineSymbol).drop(nToDrop)\n    return \"$newPattern$newLineSymbol\"\n}\n\nfun baseGenerator(firstLine: String, secondLine: String, height: Int): String {\n    val sb = StringBuilder()\n    sb.append(firstLine)\n    return when {\n        height < 1 -> \"\"\n        height == 1 -> sb.toString()\n        else -> {\n            sb.append(secondLine)\n            sb.append(repeatVertically(firstLine, secondLine, height))\n            sb.toString()\n        }\n    }\n}\n\nfun repeatVertically(firstLine: String, secondLine: String, height: Int): String {\n    val currentHeight = makeEvenNumber(height) / 2 - 1\n    val pattern = \"$firstLine$secondLine\".repeat(currentHeight)\n    return if (height % 2 == 0) {\n        pattern\n    } else {\n        \"$pattern$firstLine\"\n    }\n}\n\nfun makeEvenNumber(number: Int) = if (number % 2 == 0) {\n    number\n} else {\n    number - 1\n}\n\nfun canvasGenerator(pattern: String, width: Int, height: Int): String {\n    val patternWidth = getPatternWidth(pattern)\n    val patternHeight = getPatternHeight(pattern)\n    val repeatedPattern = repeatHorizontally(pattern, width, patternWidth)\n    val dropped = dropTopFromLine(repeatedPattern, width, patternHeight, patternWidth)\n    return \"$repeatedPattern${baseGenerator(dropped, dropped, height - 1)}\"\n}\n\nfun addEmptyWindow(patternRow: String, patternWidth: Int, toAddAfter: Boolean = false): String {\n    val separator = \"$separator\".repeat(patternWidth)\n    return if (toAddAfter) {\n        \"$patternRow$separator\"\n    } else {\n        \"$separator$patternRow\"\n    }\n}\n\nfun isEmpty(pattern: String) = pattern == \"\"\n\nfun repeatHorizontallyWithGaps(pattern: String, n: Int, toAddSeparatorAfter: Boolean): String {\n    val pictureRows = pattern.lines()\n    val patternWidth = getPatternWidth(pattern)\n    val sb = StringBuilder()\n    for (row in pictureRows) {\n        val currentRow = fillPatternRow(row, patternWidth)\n\n        val currentRwSb = StringBuilder()\n        val currentWidth = makeEvenNumber(n) / 2\n        val patternToRepeat = addEmptyWindow(currentRow, patternWidth, toAddSeparatorAfter).repeat(currentWidth)\n        if (isEmpty(patternToRepeat)) {\n            currentRwSb.append(currentRow)\n        } else {\n            currentRwSb.append(patternToRepeat)\n        }\n        if (n % 2 != 0 && !isEmpty(patternToRepeat)) {\n            currentRwSb.append(patternToRepeat.dropLast(patternToRepeat.length - currentRow.length))\n        }\n        sb.append(currentRwSb.toString())\n        sb.append(newLineSymbol)\n    }\n    return sb.toString()\n}\n\nfun canvasWithGapsGenerator(pattern: String, width: Int, height: Int): String {\n    val firstLine = repeatHorizontallyWithGaps(pattern, width, true)\n    val secondLine = repeatHorizontallyWithGaps(pattern, width, false)\n    return baseGenerator(firstLine, secondLine, height)\n}\n\nfun applyGenerator(pattern: String, generatorName: String, width: Int, height: Int) = when (generatorName) {\n    \"canvas\" -> canvasGenerator(pattern.trimIndent(), width, height)\n    \"canvasGaps\" -> canvasWithGapsGenerator(pattern.trimIndent(), width, height)\n    else -> error(\"Unsupported generator: $generatorName\")\n}\n\nfun getPattern(): String {\n    println(\n        \"Do you want to use a pre-defined pattern or a custom one? \" +\n                \"Please input 'yes' for a pre-defined pattern or 'no' for a custom one\"\n    )\n    do {\n        when (safeReadLine()) {\n            \"yes\" -> {\n                return choosePattern()\n            }\n            \"no\" -> {\n                println(\"Please, input a custom picture\")\n                return safeReadLine()\n            }\n            else -> println(\"Please input 'yes' or 'no'\")\n        }\n    } while (true)\n}\n\nfun choosePattern(): String {\n    do {\n        println(\"Please choose a pattern. The possible options: ${allPatterns().joinToString(\", \")}\")\n        val name = safeReadLine()\n        val pattern = getPatternByName(name)\n        pattern?.let {\n            return pattern\n        }\n    } while (true)\n}\n\nfun chooseGenerator(): String {\n    var toContinue = true\n    var generator = \"\"\n    println(\"Please choose the generator: 'canvas' or 'canvasGaps'.\")\n    do {\n        when (val input = safeReadLine()) {\n            \"canvas\", \"canvasGaps\" -> {\n                toContinue = false\n                generator = input\n            }\n            else -> println(\"Please, input 'canvas' or 'canvasGaps'\")\n        }\n    } while (toContinue)\n    return generator\n}\n\nfun safeReadLine(): String = readlnOrNull() ?: error(\"Your input is incorrect, sorry\")\n\nfun main() {\n    val pattern = getPattern()\n    val generatorName = chooseGenerator()\n    println(\"Please input the width of the resulting picture:\")\n    val width = safeReadLine().toInt()\n    println(\"Please input the height of the resulting picture:\")\n    val height = safeReadLine().toInt()\n\n    println(\"The pattern:$newLineSymbol${pattern.trimIndent()}\")\n\n    println(\"The generated image:\")\n    println(applyGenerator(pattern, generatorName, width, height))\n}\n"
  },
  {
    "name": "src/main/kotlin/Patterns.kt",
    "text": "val ball = \"\"\"                                                       \n  â—‹\n\"\"\".trimIndent()\n\nval rhombus = \"\"\"\n    X\n   / \\\n   \\ /\n    X\n\"\"\".trimIndent()\n\nval vase = \"\"\"  \n  ____   \n /    \\\n/ /  \\ \\\n\\ \\__/ /\n \\____/\n\"\"\".trimIndent()\n\nval robot = \"\"\"     \n+---+---+\n| o   o |\n|   ^   |\n|  ---  |\n+---+---+\n\"\"\".trimIndent()\n\nval cube = \"\"\"     \n   .+------+\n .' |    .'|\n+---+--+'  |\n|   |  |   |\n|  ,+--+---+\n|.'    | .' \n+------+'\n\"\"\".trimIndent()\n\nval allPatternsMap = mapOf(\n    \"ball\" to ball,\n    \"rhombus\" to rhombus,\n    \"vase\" to vase,\n    \"robot\" to robot,\n    \"cube\" to cube,\n)\n"
  },
  {
    "name": "src/main/kotlin/PreDefinedSymbols.kt",
    "text": "@file:Suppress(\"MayBeConst\")\n\nval separator = ' '\nval newLineSymbol = System.lineSeparator()\n\nfun getPatternWidth(pattern: String) = pattern.lines().maxOfOrNull { it.length } ?: 0\n\nfun getPatternByName(name: String) = allPatternsMap[name]\n\nfun allPatterns() = allPatternsMap.keys\n"
  },
  {
    "name": "test/CanvasGenerator.kt",
    "text": ""
  },
  {
    "name": "test/CanvasWithGapsGenerator.kt",
    "text": ""
  },
  {
    "name": "test/Helpers.kt",
    "text": ""
  },
  {
    "name": "test/PatternsGeneratorTestsUtils.kt",
    "text": ""
  },
  {
    "name": "test/Tests.kt",
    "text": ""
  },
  {
    "name": "src/main/kotlin/where_did_you_come_from.txt",
    "text": "I don't know :("
  }
]
